---
phase: 07-rich-realtime-ux
plan: 02
type: execute
wave: 2
depends_on:
  - 07-01
files_modified:
  - vc_agents/web/dashboard.html
autonomous: true
requirements:
  - UX-01
  - UX-02
  - UX-03

must_haves:
  truths:
    - "Idea cards appear in the Ideas tab one-by-one as each founder's generation event fires during Stage 1"
    - "Score badges on each idea card update with the reviewer's score as each feedback event arrives"
    - "When Stage 1 selection completes, the chosen idea card is highlighted (gold border) and rejected ideas are greyed out"
  artifacts:
    - path: "vc_agents/web/dashboard.html"
      provides: "handleStage1Ideas() — merges incoming idea data into live idea grid"
      contains: "handleStage1Ideas"
    - path: "vc_agents/web/dashboard.html"
      provides: "handleStage1Feedback() — appends score badge to existing idea card"
      contains: "handleStage1Feedback"
    - path: "vc_agents/web/dashboard.html"
      provides: "handleStage1Selection() — applies selected/rejected visual state"
      contains: "handleStage1Selection"
  key_links:
    - from: "handleEvent() WebSocket dispatcher"
      to: "handleStage1Ideas()"
      via: "ev.type === 'step_complete' && ev.stage === 'stage1' && ev.step === 'ideas'"
      pattern: "handleStage1Ideas"
    - from: "handleEvent() WebSocket dispatcher"
      to: "handleStage1Feedback()"
      via: "ev.type === 'step_complete' && ev.stage === 'stage1' && ev.step === 'feedback'"
      pattern: "handleStage1Feedback"
    - from: "handleEvent() WebSocket dispatcher"
      to: "handleStage1Selection()"
      via: "ev.type === 'stage_complete' && ev.stage === 'stage1'"
      pattern: "handleStage1Selection"
---

<objective>
Wire Stage 1 live rendering in dashboard.html so idea cards appear as events fire, score badges update per feedback, and the selection result highlights the winner.

Purpose: UX-01, UX-02, UX-03. Currently the dashboard shows only a progress bar and event log during Stage 1 execution. After this plan, the Ideas tab is a live display that updates with every WebSocket event.

Output: Three new JS functions added to dashboard.html, wired into the existing `handleEvent()` dispatcher. All changes are additive — no existing render functions are removed or simplified.
</objective>

<execution_context>
@C:/Users/Vince/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Vince/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-rich-realtime-ux/07-01-SUMMARY.md
</context>

<interfaces>
<!-- Key contracts from dashboard.html that the executor uses. Extracted directly. -->

Existing handleEvent() function (line ~1080):
```javascript
function handleEvent(ev) {
  document.getElementById('progressBlock').classList.add('visible');
  const pills = { stage1:'pill1', stage2:'pill2', stage3:'pill3' };
  if (ev.type === 'stage_start') { ... }
  if (ev.type === 'stage_complete') { ... }
  // pct progress bar logic
  if (ev.type === 'step_complete') { ... nudge progress bar by 1.5% ... }
  if (ev.type === 'pipeline_complete') { ... loadResults(currentRunId); loadRuns(); }
  if (ev.type === 'pipeline_error') { ... }
  appendEvent(ev);
}
```

Existing renderIdeas() function (line ~1218) — builds full static grid from array, sets ideasContent innerHTML.

Existing esc() utility (line ~1398) — HTML-escapes strings.

Stage 1 events from run.py (after Plan 01):
```
// Idea generation — fires once per founder
{ type: "step_complete", stage: "stage1", step: "ideas",
  provider: "openai", data: { ideas: [...idea objects...] } }

// Feedback — fires once per reviewer/idea pair
{ type: "step_complete", stage: "stage1", step: "feedback",
  provider: "anthropic", idea_id: "idea-123",
  data: { score: 7, idea_id: "idea-123" } }

// Selection complete — fires once for all founders
{ type: "stage_complete", stage: "stage1",
  data: { selections: { openai: "idea-123", anthropic: "idea-456", ... } } }
```

Idea card HTML structure (from renderIdeas):
```html
<div class="idea-card" data-idea-id="{idea_id}">
  <div class="idea-top">
    <div class="idea-title">{title}</div>
    <span class="provider-badge {provider}">{provider}</span>
  </div>
  <p class="idea-summary">{summary}</p>
  <div class="idea-details">...</div>
</div>
```

CSS already defined in dashboard.html for idea cards:
```css
.idea-card { background: var(--surface); border: 1px solid var(--border); border-radius: var(--r-lg); padding: 18px; transition: border-color .2s, transform .18s; }
.idea-card:hover { border-color: var(--border-hi); transform: translateY(-2px); }
```
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Add Stage 1 live rendering functions and wire into handleEvent()</name>
  <files>vc_agents/web/dashboard.html</files>
  <action>
Read vc_agents/web/dashboard.html fully before making any changes. The design is intentional — do NOT simplify, flatten, or rewrite any existing CSS or JS.

Make THREE additive changes:

---

**CHANGE 1: Add CSS for live-state idea cards (in the `<style>` block, after the `.idea-card:hover` rule)**

Add these new rules immediately after the `.idea-card:hover` rule (around line 412):
```css
/* ─────────────────────────── LIVE IDEA STATES ─────────────────────────── */
.idea-card.idea-selected { border-color: var(--gold); box-shadow: 0 0 0 1px var(--gold-dim); }
.idea-card.idea-rejected { opacity: .38; filter: grayscale(.6); }
.idea-score-bar {
  display: flex; gap: 5px; flex-wrap: wrap; margin-top: 10px; padding-top: 10px;
  border-top: 1px solid var(--border);
}
.idea-score-chip {
  display: inline-flex; align-items: center; gap: 4px;
  font-family: var(--font-mono); font-size: 10px; font-weight: 600;
  padding: 2px 7px; border-radius: 4px;
  background: var(--ink-2); border: 1px solid var(--border);
}
.idea-score-chip .isc-prov { font-size: 9px; color: var(--text-xs); font-weight: 400; }
```

---

**CHANGE 2: Add three JS functions before the `/* ══════════════════ INIT ══════════════════ */` comment block at the bottom of the `<script>` tag (around line 1472)**

Insert the following three functions, preserving all existing code:

```javascript
/* ══════════════════ LIVE STAGE 1 HANDLERS ══════════════════ */

// Called on step_complete / stage=stage1 / step=ideas
// ev.data.ideas = array of idea objects; ev.provider = founder name
function handleStage1Ideas(ev) {
  const ideas = (ev.data && ev.data.ideas) ? ev.data.ideas : [];
  if (!ideas.length) return;
  // Auto-switch to Ideas tab when first ideas arrive
  const ideasPane = document.getElementById('pane-ideas');
  if (!ideasPane.classList.contains('active')) switchTab('ideas');
  const el = document.getElementById('ideasContent');
  // Ensure the grid container exists
  let grid = el.querySelector('.idea-grid');
  if (!grid) {
    el.innerHTML = '<div class="idea-grid"></div>';
    grid = el.querySelector('.idea-grid');
  }
  const prov = (ev.provider || '').toLowerCase();
  for (const idea of ideas) {
    // Avoid duplicate cards if live view and loadResults both fire
    if (grid.querySelector(`[data-idea-id="${CSS.escape(idea.idea_id || '')}"]`)) continue;
    const card = document.createElement('div');
    card.className = 'idea-card';
    card.dataset.ideaId = idea.idea_id || '';
    card.innerHTML = `
      <div class="idea-top">
        <div class="idea-title">${esc(idea.title)}</div>
        <span class="provider-badge ${prov}">${esc(ev.provider)}</span>
      </div>
      <p class="idea-summary">${esc(idea.summary)}</p>
      <div class="idea-details">
        <div class="idea-drow"><span class="idea-dlabel">Target</span><span class="idea-dval">${esc(idea.target_customer)}</span></div>
        <div class="idea-drow"><span class="idea-dlabel">Why now</span><span class="idea-dval">${esc(idea.why_now)}</span></div>
        <div class="idea-drow"><span class="idea-dlabel">Market</span><span class="idea-dval">${esc(idea.market_size_estimate)}</span></div>
        <div class="idea-drow"><span class="idea-dlabel">Moat</span><span class="idea-dval">${esc(idea.unfair_advantage)}</span></div>
      </div>
      <div class="idea-score-bar"></div>`;
    grid.appendChild(card);
  }
}

// Called on step_complete / stage=stage1 / step=feedback
// ev.data.score = number; ev.data.idea_id = string; ev.provider = reviewer
function handleStage1Feedback(ev) {
  const ideaId = (ev.data && ev.data.idea_id) ? ev.data.idea_id : (ev.idea_id || '');
  const score = ev.data && ev.data.score != null ? ev.data.score : null;
  const reviewer = ev.provider || '';
  if (!ideaId) return;
  const card = document.querySelector(`[data-idea-id="${CSS.escape(ideaId)}"]`);
  if (!card) return;
  let bar = card.querySelector('.idea-score-bar');
  if (!bar) {
    bar = document.createElement('div');
    bar.className = 'idea-score-bar';
    card.appendChild(bar);
  }
  const scoreColor = score >= 7 ? 'var(--green)' : score >= 5 ? 'var(--yellow)' : 'var(--red)';
  const chip = document.createElement('span');
  chip.className = 'idea-score-chip';
  chip.style.borderColor = scoreColor;
  chip.innerHTML = `<span style="color:${scoreColor}">${score != null ? score + '/10' : '?'}</span><span class="isc-prov">${esc(reviewer)}</span>`;
  bar.appendChild(chip);
}

// Called on stage_complete / stage=stage1
// ev.data.selections = { providerName: selectedIdeaId, ... }
function handleStage1Selection(ev) {
  const selections = (ev.data && ev.data.selections) ? ev.data.selections : {};
  const selectedIds = new Set(Object.values(selections));
  // All rendered idea cards
  document.querySelectorAll('#ideasContent .idea-card[data-idea-id]').forEach(card => {
    const id = card.dataset.ideaId;
    if (selectedIds.has(id)) {
      card.classList.add('idea-selected');
      card.classList.remove('idea-rejected');
    } else {
      card.classList.add('idea-rejected');
      card.classList.remove('idea-selected');
    }
  });
}
```

---

**CHANGE 3: Wire the three new functions into the existing `handleEvent()` function**

Inside `handleEvent(ev)`, add dispatch calls for the new events. Add these lines BEFORE the existing `appendEvent(ev);` call at the bottom of `handleEvent()`:

```javascript
  // Live Stage 1 handlers
  if (ev.type === 'step_complete' && ev.stage === 'stage1' && ev.step === 'ideas') handleStage1Ideas(ev);
  if (ev.type === 'step_complete' && ev.stage === 'stage1' && ev.step === 'feedback') handleStage1Feedback(ev);
  if (ev.type === 'stage_complete' && ev.stage === 'stage1') handleStage1Selection(ev);
```

---

CRITICAL: Do NOT modify, remove, or simplify any existing CSS rules, JS functions, or HTML structure. All three changes are purely additive. The existing `renderIdeas()` function must remain untouched — `handleStage1Ideas` works alongside it (deduplication via `data-idea-id` prevents double-rendering).
  </action>
  <verify>
    <automated>cd "C:/Users/Vince/Desktop/VC_AI_Incubator-main" && python -m pytest tests/ -v -x 2>&1 | tail -10</automated>
  </verify>
  <done>
- pytest passes (server.py still loads dashboard.html without error)
- `handleStage1Ideas` function exists in dashboard.html
- `handleStage1Feedback` function exists in dashboard.html
- `handleStage1Selection` function exists in dashboard.html
- All three are called from handleEvent()
- `.idea-selected` and `.idea-rejected` CSS classes exist
- `.idea-score-chip` CSS class exists
- No existing CSS rules or JS functions were modified
  </done>
</task>

</tasks>

<verification>
```bash
cd "C:/Users/Vince/Desktop/VC_AI_Incubator-main"
python -m pytest tests/ -v 2>&1 | tail -10
grep -n "handleStage1Ideas\|handleStage1Feedback\|handleStage1Selection" vc_agents/web/dashboard.html
grep -n "idea-selected\|idea-rejected\|idea-score-chip" vc_agents/web/dashboard.html
```
All checks must pass.
</verification>

<success_criteria>
- pytest passes with zero failures
- Three new handler functions present and wired into handleEvent()
- CSS classes for live idea states present
- Existing renderIdeas(), renderFeedback(), renderPlans() functions unchanged
- No existing CSS or JS simplified or removed
</success_criteria>

<output>
After completion, create `.planning/phases/07-rich-realtime-ux/07-02-SUMMARY.md`
</output>
