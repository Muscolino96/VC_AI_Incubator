---
phase: 07-rich-realtime-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vc_agents/pipeline/run.py
autonomous: true
requirements:
  - UX-02
  - UX-05

must_haves:
  truths:
    - "A STEP_COMPLETE event fires after each individual advisor feedback item in Stage 1, carrying the feedback score and reviewer provider"
    - "A STEP_COMPLETE event fires after each plan build/iteration in Stage 2, carrying the plan version number and founder provider"
  artifacts:
    - path: "vc_agents/pipeline/run.py"
      provides: "Two new emit() calls: one in feedback_task, one after plan write"
      contains: "step=\"feedback\""
    - path: "vc_agents/pipeline/run.py"
      provides: "Plan version event"
      contains: "step=\"plan_version\""
  key_links:
    - from: "vc_agents/pipeline/run.py feedback_task"
      to: "dashboard WebSocket handler"
      via: "emit STEP_COMPLETE step=feedback"
      pattern: "step=\"feedback\""
    - from: "vc_agents/pipeline/run.py plan write block"
      to: "dashboard WebSocket handler"
      via: "emit STEP_COMPLETE step=plan_version"
      pattern: "step=\"plan_version\""
---

<objective>
Add two missing STEP_COMPLETE events to run.py so the dashboard can render live score overlays and plan version badges.

Purpose: The dashboard's live UX (Plan 02, Plan 03) needs per-feedback and per-plan-build events. Without these, advisor score badges on idea cards (UX-02) and plan version increments (UX-05) cannot update during execution.

Output: Two new emit() calls in vc_agents/pipeline/run.py — one per feedback review item, one per plan build/iteration — with structured data payloads the frontend will consume.
</objective>

<execution_context>
@C:/Users/Vince/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Vince/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
</context>

<interfaces>
<!-- Key contracts from vc_agents/pipeline/run.py and events.py. Executor uses these directly. -->

From vc_agents/pipeline/events.py:
```python
class EventType(str, Enum):
    STEP_COMPLETE = "step_complete"
    # ... others

@dataclass
class PipelineEvent:
    type: EventType
    stage: str = ""
    step: str = ""
    provider: str = ""
    idea_id: str = ""
    message: str = ""
    data: dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)
```

Existing STEP_COMPLETE events in run.py:
```python
# Stage 1 — ideas (line 460)
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage1", step="ideas",
    provider=provider.name, message=f"Generated {len(idea_items)} ideas",
    data={"ideas": idea_items},
))

# Stage 2 — review round (line 738)
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage2", step=f"review_round_{round_num}",
    provider=founder.name, idea_id=idea_id,
    message=f"Round {round_num}: avg={avg_score:.1f}, ready={all_ready}",
    data={"avg_score": avg_score, "all_ready": all_ready, "round": round_num},
))

# Stage 3 — investor decision (line 867)
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage3", step="investor_decision",
    provider=investor.name, idea_id=task["idea_id"],
    message=f"{investor.name}: {decision['decision']} (conviction {decision['conviction_score']})",
    data={"decision": decision["decision"], "conviction": decision["conviction_score"]},
))
```

Stage 1 feedback_task (line ~480):
```python
def feedback_task(task: dict[str, Any]) -> dict[str, Any]:
    idea = task["idea"]
    reviewer = task["reviewer"]
    # ... calls retry_json_call ...
    return result  # result has: score, idea_id, reviewer_provider, summary, strengths, weaknesses
```

Stage 2 plan write blocks:
```python
# Initial plan build (line 633)
_write_jsonl(run_dir / f"stage2_{founder.name}_plan_v0.jsonl", [plan])

# Iteration write (line 766)
_write_jsonl(run_dir / f"stage2_{founder.name}_plan_v{round_num}.jsonl", [plan])
```
</interfaces>

<tasks>

<task type="auto" tdd="false">
  <name>Task 1: Add per-feedback and per-plan-build events to run.py</name>
  <files>vc_agents/pipeline/run.py</files>
  <action>
Read vc_agents/pipeline/run.py fully before making changes.

Make TWO targeted additions:

**Addition 1: Per-feedback STEP_COMPLETE event**

In `run_stage1`, inside the `feedback_task` inner function (around line 480), after `return result` is computed but before returning, add an emit call. The `feedback_task` function already receives `emit` via closure (the outer `run_stage1` function receives `emit` as a parameter).

Add this emit call right before `return result` in `feedback_task`:
```python
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage1", step="feedback",
    provider=result.get("reviewer_provider", reviewer.name),
    idea_id=result.get("idea_id", idea.get("idea_id", "")),
    message=f"{reviewer.name} reviewed idea {idea.get('idea_id','')}: score={result.get('score')}",
    data={"score": result.get("score"), "idea_id": result.get("idea_id", idea.get("idea_id", ""))},
))
```

IMPORTANT: `feedback_task` is an inner function defined inside `run_stage1`. The `emit` callback is already in its closure scope. No parameter changes needed.

**Addition 2: Per-plan-build STEP_COMPLETE event**

In `_run_founder_stage2` inner function, emit after the initial plan build (after `_write_jsonl(...plan_v0.jsonl...)` on line ~633) AND after each iteration write (after `_write_jsonl(...plan_v{round_num}.jsonl...)` on line ~767).

After the v0 write:
```python
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage2", step="plan_version",
    provider=founder.name, idea_id=idea_id,
    message=f"{founder.name} built initial plan v0",
    data={"version": 0, "idea_id": idea_id},
))
```

After the v{round_num} write:
```python
emit(PipelineEvent(
    type=EventType.STEP_COMPLETE, stage="stage2", step="plan_version",
    provider=founder.name, idea_id=idea_id,
    message=f"{founder.name} iterated plan to v{round_num}",
    data={"version": round_num, "idea_id": idea_id},
))
```

IMPORTANT: `_run_founder_stage2` is also an inner function with `emit` in its closure. No signature changes needed.

Do NOT modify any other logic, schemas, file writes, or function signatures. This is an additive-only change.
  </action>
  <verify>
    <automated>cd "C:/Users/Vince/Desktop/VC_AI_Incubator-main" && python -m pytest tests/ -v -x 2>&1 | tail -20</automated>
  </verify>
  <done>
- `pytest tests/ -v` passes (all existing tests still green)
- grep confirms `step="feedback"` exists in run.py
- grep confirms `step="plan_version"` exists in run.py (appears twice — v0 and iteration)
- No function signatures changed
  </done>
</task>

</tasks>

<verification>
```bash
cd "C:/Users/Vince/Desktop/VC_AI_Incubator-main"
python -m pytest tests/ -v 2>&1 | tail -10
grep -n 'step="feedback"' vc_agents/pipeline/run.py
grep -n 'step="plan_version"' vc_agents/pipeline/run.py
```
All three commands must succeed and show the expected output.
</verification>

<success_criteria>
- pytest passes with zero failures
- `step="feedback"` emit added inside feedback_task in run_stage1
- `step="plan_version"` emit added after plan_v0 write AND after each iteration write in _run_founder_stage2
- No existing tests broken
- No function signatures modified
</success_criteria>

<output>
After completion, create `.planning/phases/07-rich-realtime-ux/07-01-SUMMARY.md`
</output>
